// Code generated by gowrap. DO NOT EDIT.
// template: https://raw.githubusercontent.com/adlandh/gowrap-templates/main/zap.gotmpl
// gowrap: http://github.com/hexdigest/gowrap

package wrappers

//go:generate gowrap gen -p github.com/adlandh/post-forwarder/internal/post-forwarder/domain -i ApplicationInterface -t https://raw.githubusercontent.com/adlandh/gowrap-templates/main/zap.gotmpl -o ApplicationInterfaceWithZap.go -l ""

import (
	"context"

	"github.com/adlandh/post-forwarder/internal/post-forwarder/domain"
	"go.uber.org/zap"
)

// ApplicationInterfaceWithZap implements domain.ApplicationInterface that is instrumented with zap logger
type ApplicationInterfaceWithZap struct {
	_base domain.ApplicationInterface
	_log  *zap.Logger
}

// NewApplicationInterfaceWithZap instruments an implementation of the domain.ApplicationInterface with simple logging
func NewApplicationInterfaceWithZap(base domain.ApplicationInterface, log *zap.Logger) ApplicationInterfaceWithZap {
	return ApplicationInterfaceWithZap{
		_base: base,
		_log:  log,
	}
}

// ProcessRequest implements domain.ApplicationInterface
func (_d ApplicationInterfaceWithZap) ProcessRequest(ctx context.Context, service string, msg string) (err error) {
	_d._log.Debug("ApplicationInterfaceWithZap: calling ProcessRequest", zap.Any("params", map[string]interface{}{
		"ctx":     ctx,
		"service": service,
		"msg":     msg}))
	defer func() {
		if err != nil {
			_d._log.Warn("ApplicationInterfaceWithZap: method ProcessRequest returned an error", zap.Error(err), zap.Any("result", map[string]interface{}{
				"err": err}))
		} else {
			_d._log.Debug("ApplicationInterfaceWithZap: method ProcessRequest finished", zap.Any("result", map[string]interface{}{
				"err": err}))
		}
	}()
	return _d._base.ProcessRequest(ctx, service, msg)
}
